## DESIGN: Deribit Storage

### 1. Цели и контекст

- **Цель проекта**: реализовать сервис, который:
  - раз в минуту запрашивает на бирже Deribit index price для `btc_usd` и `eth_usd`,
  - сохраняет в PostgreSQL пары (тикер, цена, время в UNIX timestamp),
  - предоставляет внешнее HTTP API (FastAPI) для доступа к сохранённым данным.

- **Основные пользователи**:
  - разработчики и аналитики, которым нужен простой источник исторических котировок,
  - сам автор проекта для демонстрации архитектуры, работы с async‑стеком, Celery и Docker.

### 2. Требования (из ТЗ, с уточнениями)

- **Функциональные**:
  - Периодический сбор цен для `btc_usd` и `eth_usd` (index price).
  - Сохранение: `ticker`, `price`, `timestamp` (UNIX).
  - Внешнее API на FastAPI:
    - GET: получить все сохранённые данные по валюте.
    - GET: получить последнюю цену валюты.
    - GET: получить цены с фильтром по дате.
    - Для всех методов обязательный query‑параметр `ticker`.
  - Версионирование API, например `/api/v1/...`.

- **Нефункциональные**:
  - Чистая архитектура, отсутствие глобальных переменных.
  - ООП‑подход (как минимум для клиентов и работы с данными).
  - Возможность масштабирования (увеличение частоты опроса, количества тикеров).
  - Простота локального развёртывания (Docker Compose).

- **Технологические ограничения**:
  - БД: PostgreSQL.
  - Периодические задачи: Celery.
  - Предпочтительно: async‑стек (FastAPI, async SQLAlchemy).
  - Миграции: Alembic.
  - Разбор альтернатив HTTP‑клиента (aiohttp и др.).

### 3. Архитектура (высокоуровневый обзор)

Компоненты:

- **FastAPI‑приложение**
  - HTTP‑слой: роуты, валидация входных параметров, схемы ответов.
  - Сервисный слой: бизнес‑логика чтения данных (обращается к репозиториям).

- **Celery worker**
  - Фоновые задачи по сбору цен с Deribit.
  - Планировщик (Celery beat или аналог) для запуска задач раз в минуту.

- **HTTP‑клиент к Deribit**
  - Инкапсулирует логику запросов к публичному API Deribit.
  - Скрывает детали реализации HTTP‑клиента (`aiohttp` / `httpx` / др.).

- **Слой данных**
  - ORM‑модели (SQLAlchemy async).
  - Репозитории/DAO для доступа к БД.
  - Миграции Alembic.

- **Инфраструктура**
  - Docker Compose: `app`, `db` (PostgreSQL), `broker` (Redis), `worker` (Celery), при необходимости `beat`.

### 4. Схема данных

Базовая таблица (рабочее название `ticker_prices`):

- `id` (PK, INT/BIGINT, auto-increment)
- `ticker` (TEXT / VARCHAR; например, `btc_usd`, `eth_usd`)
- `price` (DECIMAL/NUMERIC с подходящей точностью)
- `timestamp` (BIGINT, UNIX timestamp, время, на которое актуальна цена)
- `created_at` (TIMESTAMP WITH TIME ZONE, время записи в БД)

Индексы:

- индекс по `ticker` + `timestamp` (для запросов по валюте и дате),
- опционально отдельный индекс по `timestamp` (для временных срезов).

### 5. Выбор брокера для Celery

#### 5.1. Требования к брокеру

- Простота локального развёртывания (через Docker Compose).
- Достаточная надёжность для учебного проекта.
- Возможность эволюции к прод‑использованию.

#### 5.2. Кандидаты

- **Redis**:
  - **Плюсы**:
    - Очень простая конфигурация и запуск (один контейнер).
    - Хорошо поддерживается Celery.
    - Достаточно для учебного/малонагруженного проекта.
  - **Минусы**:
    - Не специализирован на очередях, меньше возможностей fine‑grained конфигурации очередей по сравнению с RabbitMQ.
    - Для прод‑нагрузок могут потребоваться дополнительные меры по надёжности/персистентности.

- **RabbitMQ**:
  - **Плюсы**:
    - Специализированный брокер сообщений c богатой моделью (exchange, routing keys, очереди).
    - Высокая надёжность, подтверждения сообщений, гибкая маршрутизация — хорошо подходит для прод‑нагрузок.
  - **Минусы**:
    - Сложнее в настройке и сопровождении.
    - Для учебного проекта может быть избыточен.

#### 5.3. Решение

- **Для учебного варианта (по умолчанию)**:
  - Использовать **Redis** как брокер Celery, поднятый отдельным сервисом в Docker Compose.

- **Для выхода «на полную мощность»**:
  - Рассмотреть **миграцию на RabbitMQ**:
    - Обновить конфигурацию Celery для работы с RabbitMQ.
    - В `ROADMAP.md` зафиксирована эта задача как часть прод‑подготовки.

### 6. HTTP‑клиент к Deribit: aiohttp и альтернативы

#### 6.1. Требования к HTTP‑клиенту

- Асинхронность (совместимость с async‑стеком FastAPI/Celery).
- Поддержка таймаутов, повторов, настройки сессий.
- Удобство тестирования (моки).

#### 6.2. Варианты

- **aiohttp**
  - **Плюсы**:
    - Один из первых и самых популярных async‑HTTP‑клиентов для Python.
    - Гибкие настройки сессий, коннект‑пула и т.д.
    - Хорошо задокументирован, широко используется.
  - **Минусы**:
    - Интерфейс ближе к «низкоуровневому» (нужно чуть больше кода, чем, например, с httpx).
    - Дополнительный event‑loop‑зависимый код при интеграции в не‑async окружения (для нас не критично).

- **httpx**
  - **Плюсы**:
    - Современный клиент с поддержкой как sync, так и async API.
    - API во многом совместим с `requests`, удобно для разработчиков, привыкших к нему.
    - Удобное тестирование (встроенные средства для мока ответов).
  - **Минусы**:
    - Чуть более молодой по сравнению с aiohttp, но уже достаточно зрелый.

- **requests** (через `run_in_executor` и т.п.)
  - **Плюсы**:
    - Де‑факто стандартный sync‑клиент, очень прост в использовании.
  - **Минусы**:
    - Синхронный: потребует обёрток, чтобы не блокировать event loop — для чистого async‑проекта менее привлекательно.

#### 6.3. Решение

- **Изначальный выбор**:  
  - Использовать **`aiohttp`** как основной HTTP‑клиент, исходя из его зрелости и ориентации на async‑сценарии.

- **Подготовка к возможной замене**:
  - Ввести абстракцию клиента (например, интерфейс/протокол `IDeribitClient` с методами `get_index_price(ticker: str) -> float`).
  - Реализовать адаптеры:
    - `AiohttpDeribitClient` — реализация на `aiohttp`.
    - Потенциально в будущем: `HttpxDeribitClient` — реализация на `httpx` без изменения остального кода.

Таким образом, смена HTTP‑клиента не потребует переписывания бизнес‑логики и задач Celery.

### 7. Архитектурный стиль и структура кода

#### 7.1. ООП‑подход vs смешанный подход

- **ООП‑подход**:
  - Основные единицы — классы с явной ответственностью:
    - `DeribitClient` (или `AiohttpDeribitClient`) — класс клиента к бирже.
    - `TickerPriceRepository` — класс для доступа к данным в БД.
    - Сервисные классы, инкапсулирующие бизнес‑операции.
  - Преимущества:
    - Чёткое разделение ответственности.
    - Легко подменять реализации (например, моки в тестах, разные клиенты).
    - Проще расширять поведение через наследование/композицию.

- **Смешанный подход**:
  - Комбинация:
    - классов там, где есть устойчивое понятие сущности/сервиса (клиент к бирже, репозиторий),
    - «плоских» модульных функций там, где логика проста (утилиты, простые операции).
  - Преимущества:
    - Меньше «служебного» кода, чем при тотальном ООП.
    - Читаемость для небольших модулей может быть выше.

**Решение для проекта**:

- Использовать **ООП для ключевых частей**:
  - HTTP‑клиент к Deribit (класс/классы).
  - Репозитории для работы с БД.
- Использовать **функциональный/модульный стиль**:
  - в роутерах FastAPI (функции‑эндпоинты),
  - в небольших утилитах и хелперах.

Это соответствует «смешанному» стилю с явным ООП в местах, где это даёт наибольшую пользу.

#### 7.2. Структура директорий (черновой вариант)

Примерная структура Python‑пакета:

- `app/`
  - `api/`
    - `v1/`
      - `routes_prices.py` — эндпоинты для работы с ценами.
  - `clients/`
    - `deribit.py` — `DeribitClient` и его реализации (`AiohttpDeribitClient` и т.п.).
  - `db/`
    - `models.py` — ORM‑модели.
    - `session.py` — создание async‑сессий, конфигурация подключения к БД.
    - `repositories.py` — классы репозиториев.
  - `tasks/`
    - `celery_app.py` — конфигурация Celery.
    - `price_fetching.py` — задачи по сбору и сохранению цен.
  - `core/`
    - `config.py` — конфигурация (переменные окружения, настройки брокера и т.д.).
    - `logging.py` — базовая настройка логирования (опционально).
  - `main.py` — точка входа FastAPI‑приложения.

Корень проекта:

- `alembic/` — миграции.
- `alembic.ini` — конфигурация Alembic.
- `docker-compose.yml` — сервисы и зависимости.
- `Dockerfile` — образ приложения.

### 8. API‑дизайн

- Базовый префикс: `/api/v1`.

Примеры эндпоинтов (рабочие варианты):

- `GET /api/v1/prices`  
  - Параметры:
    - `ticker` (обязательный),
    - возможно, пагинация (offset/limit).
  - Ответ: список записей (ticker, price, timestamp).

- `GET /api/v1/prices/last`
  - Параметры:
    - `ticker` (обязательный).
  - Ответ: одна запись — последняя цена.

- `GET /api/v1/prices/by-date`
  - Параметры:
    - `ticker` (обязательный),
    - `from_ts` / `to_ts` или аналогичные параметры для фильтрации по UNIX времени.
  - Ответ: список записей в указанном диапазоне.

Все параметры валидируются через Pydantic‑модели/схемы запросов.

### 9. Нефункциональные аспекты и путь к прод‑готовности

- **Производительность**:
  - Опрос раз в минуту для двух тикеров — минимальная нагрузка, но архитектура должна позволять:
    - увеличение числа тикеров,
    - возможность уменьшения интервала (например, до нескольких секунд) при доработке брокера и БД.

- **Надёжность**:
  - Логирование ошибок запросов к Deribit и БД.
  - При необходимости — повтор задач Celery при временных сбоях сети.

- **Эксплуатация**:
  - Для учебной версии достаточно логов контейнеров.
  - Для прод‑версии:
    - добавить метрики (например, через Prometheus),
    - настроить алерты на отставание расписания задач (если данные долго не обновляются).


